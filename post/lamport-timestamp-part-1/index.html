<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.80.0"><title>Lamport Timestamp Part 1 - Khairi Protagonist</title><meta name=description content="How do you order events that happens between and within distributed processes? Let’s assume that each of the processes keeps a list of:
 All the events that happened within itself And all events related to sending and receiving messages between processes  To sort the list of events, we would need to determine if a particular event happens before another event. One option would be to tag each event with DateTime of when the event occurred."><link rel=stylesheet href=/css/ui.css><link rel=stylesheet href=https://khairi.hafsham.com/css/syntax.css><link rel=stylesheet href=https://khairi.hafsham.com/css/override.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway"></head><body><header class="container no-print"><div class=u-header><nav class=bar><ul><li><a href=/><img class=icon-text src=/img/prev.svg></a></li><li><a href=/>Home</a></li></ul></nav></div></header><main class=container><article><header><hgroup id=brand><h1>Lamport Timestamp Part 1</h1><h5><time datetime="2021-02-14 00:00:00 +0000 UTC">Feb 14, 2021</time>
<span class=no-print><span></h5></hgroup><hr class=sep></header><p>How do you order events that happens between and within distributed processes? Let’s assume that each of the processes keeps a list of:</p><ol><li>All the events that happened within itself</li><li>And all events related to sending and receiving messages between processes</li></ol><p>To sort the list of events, we would need to determine if a particular event <em>happens before</em> another event. One option would be to tag each event with DateTime of when the event occurred. Alternatively, one could also use Unix Timestamp, instead of DateTime, and avoid all the hassle of timezone and daylight savings time. But, there is no guarantee that time runs the same in all the distributed processes. Time synchronisation with NTP have an accuracy level within tens of milliseconds, assuming the network is good and polled within 36 hours<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. Another risk would be <em>Leap Second</em> and the documented problems arising from it<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>DateTime and Unix Timestamp are considered as <em>Physical Clocks</em>. Alternative to them are <em>Logical Clock</em> and we are going to implement one of such clock called Lamport Timestamp (or Lamport’s Logical Clock). The implementation is heavily inspired by the famous paper by Leslie Lamport, titled “Time, Clocks, and the Ordering of Events in a Distributed System”<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>. Anytime <em>clock</em> is mentioned after this, it will refer to <em>Logical Clock</em>. Below are a few definitions that has been extracted from the paper.</p><h2 id=definition-def>Definition (DEF)</h2><ol><li>If <code>a</code> and <code>b</code> are events in the same process and <code>a</code> happens before <code>b</code>, then <code>a -> b</code>. The <code>-></code> means <em>happens before</em>.</li><li>If <code>a</code> is the sending of a message by one process and <code>b</code> is the receipt of the same message by another process, then <code>a -> b</code>.</li><li>If <code>a -> b</code> and <code>b -> c</code> then <code>a -> c</code>. This means the ordering of the events are transitive.</li><li>Two distinct events <code>a</code> and <code>b</code> are said to be concurrent if <code>a -/> b</code> and <code>b -/> a</code>. This would happen if <code>a</code> and <code>b</code> happens in separate processes and there were no messages sent or received among the two processes between event <code>a</code> and <code>b</code>.</li></ol><h2 id=distributed-events-between-processes>Distributed events between processes</h2><p>The logical clock can be implemented simply as a counter. To view which clock belongs to which process, we’ll create a <code>Clock</code> struct with a <code>timestamp</code> field to act as a counter and a <code>process_name</code> to identify the process it belongs to. For convenience, the code below also includes two functions for interfacing with the <code>Clock</code>:</p><ol><li><code>increment</code> which returns a new <code>Clock</code> with an incremented timestamp</li><li><code>timestamp</code> to return the timestamp value of a <code>Clock</code></li></ol><blockquote><p>Full implementation can be accessed <a href=https://github.com/khairihafsham/journal-projects/tree/main/lamport-timestamp>here</a> and each modules have a name in the first line that corresponds to a file in the repository</p></blockquote><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># clock.ex</span>
<span class=kd>defmodule</span> <span class=nc>Clock</span> <span class=k>do</span>
  <span class=kd>defstruct</span> <span class=p>[</span><span class=ss>:timestamp</span><span class=p>,</span> <span class=ss>:process_name</span><span class=p>]</span>

  <span class=kd>def</span> <span class=n>increment</span><span class=p>(</span><span class=n>clock</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>timestamp</span><span class=p>:</span> <span class=n>timestamp</span><span class=p>})</span> <span class=k>do</span>
    <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span> <span class=n>clock</span> <span class=o>|</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=n>timestamp</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>}</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>timestamp</span><span class=p>(</span><span class=n>clock</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>Map</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>clock</span><span class=p>,</span> <span class=ss>:timestamp</span><span class=p>)</span> 
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><p>For events, we would want to know the name of the event as well as when it happens. So, a clock is needed as well. Here is an example of <code>Event</code> struct that we’ll be using later on.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># event.ex</span>
<span class=kd>defmodule</span> <span class=nc>Event</span> <span class=k>do</span>
  <span class=kd>defstruct</span> <span class=p>[</span><span class=ss>:name</span><span class=p>,</span> <span class=ss>:clock</span><span class=p>]</span>

  <span class=kd>def</span> <span class=n>timestamp</span><span class=p>(</span><span class=n>event</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>Map</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=ss>:clock</span><span class=p>)</span>
    <span class=o>|&gt;</span> <span class=nc>Map</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=ss>:timestamp</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>process_name</span><span class=p>(</span><span class=n>event</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>Map</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>event</span><span class=p>,</span> <span class=ss>:clock</span><span class=p>)</span>
    <span class=o>|&gt;</span> <span class=nc>Map</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=ss>:process_name</span><span class=p>)</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><h2 id=events-ordering>Events ordering</h2><p>Let’s build something to demonstrate the clock and ordering of events between distributed processes. We’ll emulate distributed processes using <code>GenServer</code> and the application we’ll build is the Worst Random String Generator (WRSG)</p><p>We would not focus on actually building the logic for the Generator. The goal would be to demonstrate a distributed system that satisfies DEF 1 until DEF 4.</p><h3 id=implementation-rules-ir>Implementation Rules (IR)</h3><p>The implementation rules for the events and clock are quite straightforward:</p><ol><li>Each process will have its internal logical clock</li><li>When an event happens within the process, increment the clock and assign it to the event</li><li>When a process wants to send a message to another process, it will create a <code>sent</code> event</li><li>When a process receives a message from another process, it will create a <code>received</code> event</li></ol><p>We’ll start simple, with intra process events. The WRSG will be generating strings one char at a time. Every time the process receives a command to generate a char, it will create an event and observes the IR1 and IR2 above.</p><p>Here is the starting code:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># generator1.ex</span>
<span class=kn>require</span> <span class=nc>Event</span>
<span class=kn>require</span> <span class=nc>Clock</span>

<span class=kd>defmodule</span> <span class=nc>Generator</span> <span class=k>do</span>
  <span class=kn>use</span> <span class=nc>GenServer</span>

  <span class=kd>def</span> <span class=n>generate_char</span><span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=ss>:generate_char</span><span class=p>)</span> 
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>get_events</span><span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>call</span> <span class=n>name</span><span class=p>,</span> <span class=ss>:events</span>  
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>start_process</span><span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>start_link</span> <span class=n>__MODULE__</span><span class=p>,</span> <span class=p>%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span> 
  <span class=k>end</span>

  <span class=c1>### GENSERVER IMPLEMENTATIONS ###</span>

  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>init</span><span class=p>(%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>})</span> <span class=k>do</span>
    <span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=p>%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[],</span> <span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>0</span><span class=p>}}}</span> 
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Returns all the events stored in the state
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_call</span><span class=p>(</span><span class=ss>:events</span><span class=p>,</span> <span class=n>_from</span><span class=p>,</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span> <span class=p>})</span> <span class=k>do</span>
    <span class=p>{</span><span class=ss>:reply</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span> 
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Process use this to generate char internally
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>(</span><span class=ss>:generate_char</span><span class=p>,</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span><span class=ss>clock</span><span class=p>:</span> <span class=n>clock</span><span class=p>,</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span><span class=p>})</span> <span class=k>do</span>
    <span class=n>updated_clock</span> <span class=o>=</span> <span class=nc>Clock</span><span class=o>.</span><span class=n>increment</span><span class=p>(</span><span class=n>clock</span><span class=p>)</span>
    <span class=n>new_event</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span><span class=p>}</span>
    <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=p>%{</span><span class=n>state</span> <span class=o>|</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[</span> <span class=n>new_event</span> <span class=o>|</span> <span class=n>events</span><span class=p>]</span> <span class=p>}</span> <span class=p>}</span>
  <span class=k>end</span>  
<span class=k>end</span>
</code></pre></div><p>The code uses the <code>Clock</code> and <code>Event</code> structs defined earlier. When the process starts, in <code>init</code>, you’ll notice that the process initializes a <code>Clock</code> and stores it in its state. This will be its internal logical Clock and fulfils IR1.</p><p>Next, in <code>handle_cast(:generate_char, ...)</code>, the process:</p><ol><li>Gets its internal clock and increment it</li><li>Create a new <code>Event</code> with the updated clock</li><li>Updates its internal clock</li></ol><p>Let’s try running this in <code>iex</code> (it is assumed that <code>Clock</code>, <code>Event</code> and <code>Generator</code> are already compiled)</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>get_events</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=p>[</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>}</span>
<span class=p>]</span>
</code></pre></div><p>Events within a process are simple enough. We’ll move on to the interesting bit, combining with events between processes. The goal is to have 3 processes, each with its task to complete and have messages sent from one process to another. Below is a space-time diagram to illustrate what we want to achieve.</p><p><figure><img src=lamport-space-time-diagram.png alt="Space-time diagram. Created using Excalidraw"><figcaption>Fig. 1: Space-time diagram. Created using Excalidraw</figcaption></figure></p><p>Each vertical line is a process, the arrows are messages being sent from one process to another and each dot is an event. Here the events are colour coded. The vertical direction also helps to display movement of “time”, bottom to top representing oldest to latest. The horizontal direction represents space, to indicate that processes are isolated from one another.</p><p>If we would like our processes to behave as in <em>Fig. 1</em>, calling <code>generate_char</code> from <code>iex</code> will not be adequate. We’ll need a way to inform the process of the tasks that it needs to perform. To achieve that, we’ll add a new state to the process, which is an anonymous function that will contain the necessary steps for the process to execute. Since the tasks for the process are within the anonymous function, we’ll need a way to kick off the process, let’s create a new function for that as well. Here are the changes and new methods.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># generator2.ex</span>
<span class=kd>defmodule</span> <span class=nc>Generator</span> <span class=k>do</span>
  <span class=c1># Only showing the changes from the previous Generator code</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  func will be function that contains the tasks to be executed
</span><span class=sh>  by the process when run() is called
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=kd>def</span> <span class=n>start_process</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>func</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>start_link</span> <span class=n>__MODULE__</span><span class=p>,</span> <span class=p>%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>func</span><span class=p>:</span> <span class=n>func</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span> 
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>run</span><span class=p>(</span><span class=n>name</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>name</span><span class=p>,</span> <span class=ss>:run</span>
  <span class=k>end</span>

  <span class=c1>### GENSERVER IMPLEMENTATIONS ###</span>

  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>init</span><span class=p>(%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>func</span><span class=p>:</span> <span class=n>func</span><span class=p>})</span> <span class=k>do</span>
    <span class=p>{</span><span class=ss>:ok</span><span class=p>,</span> <span class=p>%{</span><span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>func</span><span class=p>:</span> <span class=n>func</span><span class=p>,</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[],</span> <span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>0</span><span class=p>}}}</span> 
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  This is for kickstarting the execution
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>(</span><span class=ss>:run</span><span class=p>,</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>func</span><span class=p>:</span> <span class=n>func</span> <span class=p>})</span> <span class=k>do</span>
    <span class=n>func</span><span class=o>.</span><span class=p>()</span>        

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><p>Fire up the <code>iex</code> again and lets try to generate the same list of events as we did previously.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=n>iex</span><span class=o>&gt;</span> <span class=n>fun</span> <span class=o>=</span> <span class=k>fn</span><span class=p>()</span> <span class=o>-&gt;</span>
   <span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
   <span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
   <span class=o>&gt;</span> <span class=k>end</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process</span><span class=p>(</span><span class=ss>:k</span><span class=p>,</span> <span class=n>fun</span><span class=p>)</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>get_events</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
<span class=p>[</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>}</span>
<span class=p>]</span>
</code></pre></div><p>Great! Now we could start different <code>Generator</code> processes that will run different steps if needed. Next, we need a few functions to <code>send</code> and <code>receive</code> messages between processes. A process will use these functions to ask the other process to do work. For convenience, a few functions also being added to start off the 3 difference processes including the tasks that each process should be executing. There is also a new function named <code>get_all_events</code>for gathering events from all the processes.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># generator3.ex</span>
<span class=kd>defmodule</span> <span class=nc>Generator</span> <span class=k>do</span>
  <span class=c1># Only showing the changes from the previous Generator code</span>
 <span class=kd>def</span> <span class=n>start_process_k</span> <span class=k>do</span>
    <span class=n>fun</span> <span class=o>=</span> <span class=k>fn</span><span class=p>()</span> <span class=o>-&gt;</span>
      <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>  
      <span class=nc>Generator</span><span class=o>.</span><span class=n>send_generate_message</span><span class=p>(</span><span class=ss>:k</span><span class=p>,</span> <span class=ss>:j</span><span class=p>)</span>
      <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>  
    <span class=k>end</span>

    <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process</span><span class=p>(</span><span class=ss>:k</span><span class=p>,</span> <span class=n>fun</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>start_process_j</span> <span class=k>do</span>
    <span class=n>fun</span> <span class=o>=</span> <span class=k>fn</span><span class=p>()</span> <span class=o>-&gt;</span>
      <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:j</span><span class=p>)</span>  
      <span class=nc>Generator</span><span class=o>.</span><span class=n>send_generate_message</span><span class=p>(</span><span class=ss>:j</span><span class=p>,</span> <span class=ss>:i</span><span class=p>)</span>
      <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:j</span><span class=p>)</span>  
    <span class=k>end</span>

    <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process</span><span class=p>(</span><span class=ss>:j</span><span class=p>,</span> <span class=n>fun</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>start_process_i</span> <span class=k>do</span>
    <span class=n>fun</span> <span class=o>=</span> <span class=k>fn</span><span class=p>()</span> <span class=o>-&gt;</span>
      <span class=nc>Generator</span><span class=o>.</span><span class=n>generate_char</span><span class=p>(</span><span class=ss>:i</span><span class=p>)</span>  
    <span class=k>end</span>

    <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process</span><span class=p>(</span><span class=ss>:i</span><span class=p>,</span> <span class=n>fun</span><span class=p>)</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>get_all_events</span> <span class=k>do</span>
    <span class=n>get_events</span><span class=p>(</span><span class=ss>:k</span><span class=p>)</span>
    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>get_events</span><span class=p>(</span><span class=ss>:j</span><span class=p>))</span>
    <span class=o>|&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>concat</span><span class=p>(</span><span class=n>get_events</span><span class=p>(</span><span class=ss>:i</span><span class=p>))</span>
  <span class=k>end</span>

  <span class=kd>def</span> <span class=n>send_generate_message</span><span class=p>(</span><span class=n>from</span><span class=p>,</span> <span class=n>to</span><span class=p>)</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>from</span><span class=p>,</span> <span class=p>{</span><span class=ss>:send_generate_message</span><span class=p>,</span> <span class=n>to</span><span class=p>}</span>  
  <span class=k>end</span>

  <span class=c1>### GENSERVER IMPLEMENTATIONS ###</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  This is to simulate an API for a process to receive message from other processes to generate chars
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:generate</span><span class=p>,</span> <span class=n>from</span> <span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span> <span class=p>})</span> <span class=k>do</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>name</span><span class=p>,</span> <span class=p>{</span><span class=ss>:received</span><span class=p>,</span> <span class=n>from</span><span class=p>}</span>
    <span class=n>run</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span>
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  A process uses this function to send a message to other process
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:send_generate_message</span><span class=p>,</span> <span class=n>to</span><span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>clock</span> <span class=p>})</span> <span class=k>do</span>
    <span class=n>updated_clock</span> <span class=o>=</span> <span class=nc>Clock</span><span class=o>.</span><span class=n>increment</span><span class=p>(</span><span class=n>clock</span><span class=p>)</span>
    <span class=n>new_event</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to </span><span class=si>#{</span><span class=n>to</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}</span>
    <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[</span> <span class=n>new_event</span> <span class=o>|</span> <span class=n>events</span> <span class=p>]</span> <span class=p>}</span>

    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>to</span><span class=p>,</span> <span class=p>{</span> <span class=ss>:generate</span><span class=p>,</span> <span class=n>name</span> <span class=p>}</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}}</span>
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Here is the logic for creating an event to indicate the process has received a message.
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:received</span><span class=p>,</span> <span class=n>from</span> <span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>clock</span> <span class=p>})</span> <span class=k>do</span>
    <span class=n>updated_clock</span> <span class=o>=</span> <span class=nc>Clock</span><span class=o>.</span><span class=n>increment</span><span class=p>(</span><span class=n>clock</span><span class=p>)</span>
    <span class=n>new_event</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from </span><span class=si>#{</span><span class=n>from</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span><span class=p>}</span>
    <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[</span> <span class=n>new_event</span> <span class=o>|</span> <span class=n>events</span><span class=p>]</span> <span class=p>}</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}}</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><p>The main changes surround the three new <code>handle_cast</code> functions. First is <code>handle_cast({ :generate, ...</code>, this is how the processes can receive a message from another process to begin executing its tasks. Before it calls <code>run</code> notice that, the first thing a process does is to invoke <code>handle_cast({ :received, ...</code>, which creates a new event to mark that it has received a message. The last function is <code>handle_cast({ :send_generate_message, ...</code>, this function’s main purpose is to create a new event before actually sending the message.</p><p>Let’s give it a run in <code>iex</code></p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process_k</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process_j</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>start_process_i</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>run</span> <span class=ss>:k</span>
</code></pre></div><p>Now that all the processes are running, if we call <code>Generator.get_all_events()</code> and try to sort the resulting list of events, we should get something like below:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=n>iex</span><span class=o>&gt;</span> <span class=n>events</span> <span class=o>=</span> <span class=nc>Generator</span><span class=o>.</span><span class=n>get_all_events</span><span class=p>()</span>
<span class=n>iex</span><span class=o>&gt;</span> <span class=nc>Enum</span><span class=o>.</span><span class=n>sort</span><span class=p>(</span><span class=n>events</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;2</span><span class=p>)))</span>
<span class=p>[</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>4</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>3</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to i&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>3</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:i</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to j&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:i</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from j&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from k&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>}</span>
<span class=p>]</span>
</code></pre></div><p>If compared to <em>Fig. 1</em>, the events are not sorted properly. There are a couple of reasons for this, but one of them is because our implementation violated DEF 2. To fix that, we have to alter our implementation rules a bit. Changes are in bold:</p><h3 id=updated-implementation-rules>Updated Implementation Rules</h3><ol><li>Each process will have its internal logical clock</li><li>When an event happens within the process, increment the clock and assign it to the event</li><li>When a process wants to send a message to another process, it will create a <code>sent</code> event</li><li>When a process receives a message from another process, it will:<ol><li><strong>Updates its internal logical clock to <code>max(message_timestamp, process_timestamp)</code></strong></li><li><strong>Create a <code>received</code> event</strong></li></ol></li></ol><p>Let’s update a few functions. Changes are marked in the code.</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=c1># generator4.ex</span>
<span class=kd>defmodule</span> <span class=nc>Generator</span> <span class=k>do</span>

 <span class=c1>### GENSERVER IMPLEMENTATIONS ###</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  This is to simulate an API for a process to receive message from other processes to generate chars
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:generate</span><span class=p>,</span> <span class=n>message_timestamp</span><span class=p>,</span> <span class=n>from</span> <span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span> <span class=p>})</span> <span class=k>do</span>
    <span class=c1># CHANGE: added message_timestamp of sender</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>name</span><span class=p>,</span> <span class=p>{</span><span class=ss>:received</span><span class=p>,</span> <span class=n>message_timestamp</span><span class=p>,</span> <span class=n>from</span><span class=p>}</span>
    <span class=n>run</span><span class=p>(</span><span class=n>name</span><span class=p>)</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=n>state</span><span class=p>}</span>
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  A process uses this function to send a message to other process
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:send_generate_message</span><span class=p>,</span> <span class=n>to</span><span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>name</span><span class=p>:</span> <span class=n>name</span><span class=p>,</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>clock</span> <span class=p>})</span> <span class=k>do</span>
    <span class=n>updated_clock</span> <span class=o>=</span> <span class=nc>Clock</span><span class=o>.</span><span class=n>increment</span><span class=p>(</span><span class=n>clock</span><span class=p>)</span>
    <span class=n>new_event</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to </span><span class=si>#{</span><span class=n>to</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}</span>
    <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[</span> <span class=n>new_event</span> <span class=o>|</span> <span class=n>events</span> <span class=p>]</span> <span class=p>}</span>

    <span class=c1># CHANGE send process timestamp to receiver</span>
    <span class=nc>GenServer</span><span class=o>.</span><span class=n>cast</span> <span class=n>to</span><span class=p>,</span> <span class=p>{</span> <span class=ss>:generate</span><span class=p>,</span> <span class=p>%</span><span class=nc>Clock</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=n>updated_clock</span><span class=p>),</span> <span class=n>name</span> <span class=p>}</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}}</span>
  <span class=k>end</span>

  <span class=na>@doc</span> <span class=sh>&#34;&#34;&#34;
</span><span class=sh>  Here is the logic for creating an event to indicate the process has received a message.
</span><span class=sh>  &#34;&#34;&#34;</span>
  <span class=na>@impl</span> <span class=no>true</span>
  <span class=kd>def</span> <span class=n>handle_cast</span><span class=p>({</span> <span class=ss>:received</span><span class=p>,</span> <span class=n>message_timestamp</span><span class=p>,</span> <span class=n>from</span> <span class=p>},</span> <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=ss>events</span><span class=p>:</span> <span class=n>events</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>clock</span> <span class=p>})</span> <span class=k>do</span>
    <span class=c1># CHANGE take whichever the latest timestamp and create a new event using it</span>
    <span class=n>latest_timestamp</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=nc>Clock</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=n>clock</span><span class=p>),</span> <span class=n>message_timestamp</span><span class=p>)</span>
    <span class=n>updated_clock</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span> <span class=n>clock</span> <span class=o>|</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=n>latest_timestamp</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>}</span>

    <span class=n>new_event</span> <span class=o>=</span> <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from </span><span class=si>#{</span><span class=n>from</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>,</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span><span class=p>}</span>
    <span class=n>state</span> <span class=o>=</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>events</span><span class=p>:</span> <span class=p>[</span> <span class=n>new_event</span> <span class=o>|</span> <span class=n>events</span><span class=p>]</span> <span class=p>}</span>

    <span class=p>{</span><span class=ss>:noreply</span><span class=p>,</span> <span class=p>%{</span> <span class=n>state</span> <span class=o>|</span> <span class=ss>clock</span><span class=p>:</span> <span class=n>updated_clock</span> <span class=p>}}</span>
  <span class=k>end</span>
<span class=k>end</span>
</code></pre></div><p>If we repeat all the steps again, we’ll get:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=p>[</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:i</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>7</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:i</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>6</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from j&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>6</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>5</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to i&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>4</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:j</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>3</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;received from k&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>3</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>2</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=s2>&#34;sent to j&#34;</span><span class=p>},</span>
  <span class=p>%</span><span class=nc>Event</span><span class=p>{</span><span class=ss>clock</span><span class=p>:</span> <span class=p>%</span><span class=nc>Clock</span><span class=p>{</span><span class=ss>process_name</span><span class=p>:</span> <span class=ss>:k</span><span class=p>,</span> <span class=ss>timestamp</span><span class=p>:</span> <span class=mi>1</span><span class=p>},</span> <span class=ss>name</span><span class=p>:</span> <span class=ss>:generate_char</span><span class=p>}</span>
<span class=p>]</span>
</code></pre></div><p>Now it looks better. But, there are a couple of events that still have the same timestamp and they can swap places on each ordering because their value are the same. These events are an example of <code>concurrent</code> events, as mentioned in DEF 4. And this particular kind of ordering is called <code>partial ordering</code>.</p><p>The paper suggest that we could achieve <code>total ordering</code>, where there are no ambiguity or events swapping places, if we can find a way to break the tie. One way to achieve that is to give each process a weight and use the weight as a tiebreaker. For example, we could determine that process <code>k > j > i</code> and if there are any events that share the same <code>timestamp</code>, we could fall back to the process hierarchy to determine which event sits higher in the ordering. Since in Elixir, inequality operation of atoms will use their string value, this can be achieved by changing the sorting logic to:</p><div class=highlight><pre class=chroma><code class=language-elixir data-lang=elixir><span class=o>&amp;</span><span class=p>((</span><span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;2</span><span class=p>))</span> <span class=o>||</span> <span class=p>((</span><span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;1</span><span class=p>)</span> <span class=o>==</span> <span class=nc>Event</span><span class=o>.</span><span class=n>timestamp</span><span class=p>(</span><span class=ni>&amp;2</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nc>Event</span><span class=o>.</span><span class=n>process_name</span><span class=p>(</span><span class=ni>&amp;1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nc>Event</span><span class=o>.</span><span class=n>process_name</span><span class=p>(</span><span class=ni>&amp;2</span><span class=p>)))</span>
</code></pre></div><p>So far, we have learned about how to use Logical Clocks instead of Physical Clocks for generating and ordering events in a distributed process. In part 2, we’ll explore how to use <code>Lamport Timestamp</code> for making decision within a distributed system and how to handle out of order events.</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p><a href=https://tools.ietf.org/html/rfc5905>https://tools.ietf.org/html/rfc5905</a> <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2 role=doc-endnote><p><a href=https://en.wikipedia.org/wiki/Leap_second#Issues_created_by_insertion_(or_removal)_of_leap_seconds>Leap second issues</a> <a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3 role=doc-endnote><p><a href=https://lamport.azurewebsites.net/pubs/time-clocks.pdf>https://lamport.azurewebsites.net/pubs/time-clocks.pdf</a> <a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></article><nav class="no-print post-nav"></nav><hr class=sep></main><footer class="container no-print"><div class=u-footer><a href=https://github.com/khairihafsham><img class=icon-social src=/img/github.svg alt=Github></a>
<a href=https://khairi.hafsham.com/index.xml target=_blank><img class=icon-social src=/img/feed.svg alt=Feed></a><p>Theme used: <a href=https://github.com/yursan9/manis-hugo-theme>Manis</a><br></p><a href=#brand><img class=icon-text src=/img/toup.svg alt="To Up">
<span>Back to Up</span></a></div></footer></body></html>